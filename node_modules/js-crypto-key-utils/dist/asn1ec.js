"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toJWK = exports.fromJWK = void 0;

var _asn = _interopRequireDefault(require("asn1.js"));

var _params = _interopRequireWildcard(require("./params.js"));

var _octenc = require("./octenc.js");

/**
 * asn1ec.js
 */

/**
 * Convert JWK to parsed ASN.1 EC key object
 * @param {JsonWebKey} jwk - A key object in JWK format.
 * @param {PublicOrPrivate} type - 'public' or 'private'
 * @param {boolean} [compact=false] - *Only for EC public keys*, the compact form of public key is given as ASN.1 object if true.
 * @return {Object} - Parsed ASN.1 object.
 */
var fromJWK = function fromJWK(jwk, type) {
  var compact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (Object.keys(_params.default.namedCurves).indexOf(jwk.crv) < 0) throw new Error('UnsupportedCurve');
  var octetPublicKey = (0, _octenc.fromJwk)(jwk, {
    outputFormat: 'binary',
    outputPublic: true,
    compact: compact
  });
  var publicKeyAlgorithmOid = _params.default.publicKeyAlgorithms['EC'].oid;
  var publicKey = {
    unused: 0,
    data: Array.from(octetPublicKey)
  }; //Buffer.from(octkeyObj.publicKey)};

  var parameters = ECParameters.encode({
    type: 'namedCurve',
    value: _params.default.namedCurves[jwk.crv].oid
  }, 'der');
  var algorithm = {
    algorithm: publicKeyAlgorithmOid,
    parameters: parameters
  };
  var decoded = {};

  if (type === 'public') {
    // SPKI
    decoded.subjectPublicKey = publicKey;
    decoded.algorithm = algorithm;
  } else if (type === 'private') {
    // PKCS8
    var octetPrivateKey = (0, _octenc.fromJwk)(jwk, {
      outputFormat: 'binary',
      outputPublic: false,
      compact: compact
    });
    decoded.version = 0; // no public key presents for v2 (0)

    decoded.privateKeyAlgorithm = algorithm;
    decoded.privateKey = ECPrivateKey.encode({
      version: 1,
      privateKey: Array.from(octetPrivateKey),
      //Buffer.from(octkeyObj.privateKey),
      parameters: parameters,
      publicKey: publicKey
    }, 'der');
  }

  return decoded;
};
/**
 * Convert parsed ASN.1 EC key object to JWK.
 * @param {Object} decoded - Parsed ASN.1 EC key object.
 * @param {PublicOrPrivate} type - 'public' or 'private'
 * @return {JsonWebKey} - Converted key objects in JWK format.
 * @throws {Error} - Throws if UnsupportedCurve.
 */


exports.fromJWK = fromJWK;

var toJWK = function toJWK(decoded, type) {
  if (type === 'public') {
    // SPKI
    decoded.algorithm.parameters = ECParameters.decode(decoded.algorithm.parameters, 'der'); // overwrite nested binary object as parsed object

    var octPubKey = new Uint8Array(decoded.subjectPublicKey.data); // convert oct key to jwk

    var namedCurves = (0, _params.getAlgorithmFromOid)(decoded.algorithm.parameters.value, _params.default.namedCurves);
    if (namedCurves.length < 1) throw new Error('UnsupportedCurve');
    return (0, _octenc.toJwk)(octPubKey, namedCurves[0], {
      outputPublic: true
    });
  } else if (type === 'private') {
    // PKCS8
    decoded.privateKeyAlgorithm.parameters = ECParameters.decode(decoded.privateKeyAlgorithm.parameters, 'der'); // Work around for optional private key parameter field.

    try {
      decoded.privateKey = ECPrivateKey.decode(decoded.privateKey, 'der');
    } catch (e) {
      decoded.privateKey = ECPrivateKeyAlt.decode(decoded.privateKey, 'der');
    }

    var octPrivKey = new Uint8Array(decoded.privateKey.privateKey);

    var _namedCurves = (0, _params.getAlgorithmFromOid)(decoded.privateKeyAlgorithm.parameters.value, _params.default.namedCurves);

    if (_namedCurves.length < 1) throw new Error('UnsupportedCurve');
    return (0, _octenc.toJwk)(octPrivKey, _namedCurves[0], {
      outputPublic: false
    });
  }
}; /////////////////////////

/**
 * ECParameters specified in RFC 5480 {@link https://tools.ietf.org/html/rfc5480}.
 * @type {AsnObject}
 */


exports.toJWK = toJWK;

var ECParameters = _asn.default.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  });
});
/**
 * ECPrivateKey specified in RFC 5915 {@link https://tools.ietf.org/html/rfc5915}.
 * @type {AsnObject}
 */


var ECPrivateKey = _asn.default.define('ECPrivateKey', function () {
  this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented
  this.key('publicKey').explicit(1).optional().bitstr() // rfc suggested that this must be implemented
  );
});
/**
 * ECPrivateKey Alternative for an work around...
 * @type {AsnObject}
 */


var ECPrivateKeyAlt = _asn.default.define('ECPrivateKey', function () {
  this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), // this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented
  this.key('publicKey').explicit(1).optional().bitstr() // rfc suggested that this must be implemented
  );
});