"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compute = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _params = _interopRequireDefault(require("./params.js"));

var util = _interopRequireWildcard(require("js-crypto-env"));

var _jsCryptoRandom = _interopRequireDefault(require("js-crypto-random"));

var _jsCryptoHmac = _interopRequireDefault(require("js-crypto-hmac"));

/**
 * hkdf.js
 */

/**
 * Hash-based Key Derivation Function computing from given master secret and salt.
 * If salt is not given, salt would be automatically generated inside.
 * Specification is given in RFC5869 {@link https://tools.ietf.org/html/rfc5869}.
 * @param {Uint8Array} master - Master secret to derive the key.
 * @param {String} [hash='SHA-256] - Name of hash algorithm used to derive the key.
 * @param {Number} [length = 32] - Intended length of derived key.
 * @param {String} [info=''] - String for information field of HKDF.
 * @param {Uint8Array} [salt=null] - Byte array of salt.
 * @return {Promise<{key: Uint8Array, salt: Uint8Array}>} - Derived key and salt used to derive the key.
 */
var compute =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(master) {
    var hash,
        length,
        info,
        salt,
        webCrypto,
        key,
        masterObj,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            hash = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'SHA-256';
            length = _args.length > 2 && _args[2] !== undefined ? _args[2] : 32;
            info = _args.length > 3 && _args[3] !== undefined ? _args[3] : '';
            salt = _args.length > 4 && _args[4] !== undefined ? _args[4] : null;
            if (!info) info = '';
            webCrypto = util.getWebCrypto(); // web crypto api

            if (salt) {
              _context.next = 10;
              break;
            }

            _context.next = 9;
            return _jsCryptoRandom.default.getRandomBytes(length);

          case 9:
            salt = _context.sent;

          case 10:
            if (!(typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.deriveBits === 'function' && typeof window.msCrypto === 'undefined')) {
              _context.next = 28;
              break;
            }

            _context.prev = 11;
            _context.next = 14;
            return webCrypto.importKey('raw', master, {
              name: 'HKDF'
            }, false, ['deriveKey', 'deriveBits']);

          case 14:
            masterObj = _context.sent;
            _context.next = 17;
            return webCrypto.deriveBits({
              name: 'HKDF',
              salt: salt,
              info: new Uint8Array(info),
              hash: hash
            }, masterObj, length * 8);

          case 17:
            key = _context.sent;
            key = new Uint8Array(key);
            _context.next = 26;
            break;

          case 21:
            _context.prev = 21;
            _context.t0 = _context["catch"](11);
            _context.next = 25;
            return rfc5869(master, hash, length, info, salt);

          case 25:
            key = _context.sent;

          case 26:
            _context.next = 31;
            break;

          case 28:
            _context.next = 30;
            return rfc5869(master, hash, length, info, salt);

          case 30:
            key = _context.sent;

          case 31:
            return _context.abrupt("return", {
              key: key,
              salt: salt
            });

          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[11, 21]]);
  }));

  return function compute(_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Naive implementation of RFC5869 in PureJavaScript
 * @param {Uint8Array} master - Master secret to derive the key.
 * @param {String} hash - Name of hash algorithm used to derive the key.
 * @param {Number} length - Intended length of derived key.
 * @param {String} info - String for information field of HKDF.
 * @param {Uint8Array} salt - Byte array of salt.
 * @return {Promise<Uint8Array>} - Derived key.
 */


exports.compute = compute;

var rfc5869 =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(master, hash, length, info, salt) {
    var len, prk, t, okm, uintInfo, i, concat;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            len = _params.default.hashes[hash].hashSize; // RFC5869 Step 1 (Extract)

            _context2.next = 3;
            return _jsCryptoHmac.default.compute(salt, master, hash);

          case 3:
            prk = _context2.sent;
            // RFC5869 Step 2 (Expand)
            t = new Uint8Array([]);
            okm = new Uint8Array(Math.ceil(length / len) * len);
            uintInfo = new Uint8Array(info);
            i = 0;

          case 8:
            if (!(i < Math.ceil(length / len))) {
              _context2.next = 20;
              break;
            }

            concat = new Uint8Array(t.length + uintInfo.length + 1);
            concat.set(t);
            concat.set(uintInfo, t.length);
            concat.set(new Uint8Array([i + 1]), t.length + uintInfo.length);
            _context2.next = 15;
            return _jsCryptoHmac.default.compute(prk, concat, hash);

          case 15:
            t = _context2.sent;
            okm.set(t, len * i);

          case 17:
            i++;
            _context2.next = 8;
            break;

          case 20:
            return _context2.abrupt("return", okm.slice(0, length));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function rfc5869(_x2, _x3, _x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();