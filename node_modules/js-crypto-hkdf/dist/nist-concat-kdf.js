"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nistConcatKdf = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _params = _interopRequireDefault(require("./params"));

var _jsCryptoHash = _interopRequireDefault(require("js-crypto-hash"));

// Deriving KEK
// https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf
// https://tools.ietf.org/html/rfc7518

/**
 * NIST Concatenation KDF fo JOSE
 * @param sharedSecret {Uint8Array} - ECDH Output
 * @param otherInfoBytes {Uint8Array} - other info
 * @param keyDataLen {number} - output key length in bytes
 * @param hash {string} - the default is 'SHA-256'
 * @return {Promise<Uint8Array>}
 */
var nistConcatKdf =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(sharedSecret, otherInfoBytes) {
    var keyDataLen,
        hash,
        reps,
        output,
        counter,
        i,
        msg,
        ki,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            keyDataLen = _args.length > 2 && _args[2] !== undefined ? _args[2] : 32;
            hash = _args.length > 3 && _args[3] !== undefined ? _args[3] : 'SHA-256';
            reps = Math.ceil(keyDataLen / _params.default.hashes[hash].hashSize);

            if (!(reps > Math.pow(2, 32) - 1)) {
              _context.next = 5;
              break;
            }

            throw new Error('TooLongKeyDataIndicated');

          case 5:
            output = new Uint8Array(_params.default.hashes[hash].hashSize * reps);
            counter = new Uint8Array(4);
            i = 0;

          case 8:
            if (!(i < reps)) {
              _context.next = 21;
              break;
            }

            counter = increment(counter);
            msg = new Uint8Array(4 + sharedSecret.length + otherInfoBytes.length);
            msg.set(counter);
            msg.set(sharedSecret, counter.length);
            msg.set(otherInfoBytes, counter.length + sharedSecret.length);
            _context.next = 16;
            return _jsCryptoHash.default.compute(msg, hash);

          case 16:
            ki = _context.sent;
            output.set(ki, i * _params.default.hashes[hash].hashSize);

          case 18:
            i++;
            _context.next = 8;
            break;

          case 21:
            return _context.abrupt("return", output.slice(0, keyDataLen));

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function nistConcatKdf(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.nistConcatKdf = nistConcatKdf;

var increment = function increment(counter) {
  counter[3] += 1;
  var up = true;
  var i = 3;

  while (up && i > 0) {
    counter[i - 1] += up && counter[i] === 0 ? 1 : 0;
    up = up && counter[i] === 0;
    i--;
  }

  return counter;
};