"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decrypt = exports.encrypt = exports.verify = exports.sign = exports.generateKey = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _jsCryptoEc = _interopRequireDefault(require("js-crypto-ec"));

var _jsCryptoRsa = _interopRequireDefault(require("js-crypto-rsa"));

var _key = require("js-crypto-key-utils/dist/key");

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var pkcec = _interopRequireWildcard(require("./pkcec.js"));

var _params = _interopRequireDefault(require("./params.js"));

/**
 * pkc.js
 */

/**
 * Generate key pair in JWK format
 * @param {'EC'|'RSA'} [keyType='EC'] - Type of public/private key.
 * @param {ECKeyGenerationOption|RSAKeyGenerationOption} [options={}] - Key generation options.
 * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>} - Generated key pair in JWK format.
 */
var generateKey =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee() {
    var keyType,
        options,
        localOpt,
        kp,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            keyType = _args.length > 0 && _args[0] !== undefined ? _args[0] : 'EC';
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            localOpt = (0, _lodash.default)(options);

            if (!(keyType === 'EC')) {
              _context.next = 10;
              break;
            }

            if (typeof localOpt.namedCurve === 'undefined') localOpt.namedCurve = 'P-256';
            _context.next = 7;
            return _jsCryptoEc.default.generateKey(localOpt.namedCurve);

          case 7:
            kp = _context.sent;
            _context.next = 19;
            break;

          case 10:
            if (!(keyType === 'RSA')) {
              _context.next = 18;
              break;
            }

            if (typeof localOpt.modulusLength === 'undefined') localOpt.modulusLength = 2048;
            if (typeof localOpt.publicExponent === 'undefined') localOpt.publicExponent = new Uint8Array([0x01, 0x00, 0x01]);
            _context.next = 15;
            return _jsCryptoRsa.default.generateKey(localOpt.modulusLength, localOpt.publicExponent);

          case 15:
            kp = _context.sent;
            _context.next = 19;
            break;

          case 18:
            throw new Error('UnsupportedKeyType');

          case 19:
            return _context.abrupt("return", {
              publicKey: new _key.Key('jwk', kp.publicKey),
              privateKey: new _key.Key('jwk', kp.privateKey)
            });

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function generateKey() {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Sign message with given private key in jwk
 * @param {Uint8Array} msg - Message byte array to be signed.
 * @param {Key} privateKey - Private key object for signing.
 * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.
 * @param {RSASigningOption|ECSigningOption} [options={}] - Signing options.
 * @return {Promise<Uint8Array>} - Signature byte array.
 * @throws {Error} - Throws if NonKeyObject or UnsupportedKeyType.
 */


exports.generateKey = generateKey;

var sign =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(msg, privateKey) {
    var hash,
        options,
        privateJwk,
        localOpt,
        signature,
        _args2 = arguments;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            hash = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 'SHA-256';
            options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};

            if (privateKey instanceof _key.Key) {
              _context2.next = 4;
              break;
            }

            throw new Error('NonKeyObject');

          case 4:
            _context2.next = 6;
            return privateKey.export('jwk');

          case 6:
            privateJwk = _context2.sent;
            localOpt = (0, _lodash.default)(options);

            if (!(privateJwk.kty === 'EC')) {
              _context2.next = 15;
              break;
            }

            if (typeof localOpt.format === 'undefined') localOpt.format = 'raw';
            _context2.next = 12;
            return _jsCryptoEc.default.sign(msg, privateJwk, hash, localOpt.format);

          case 12:
            signature = _context2.sent;
            _context2.next = 24;
            break;

          case 15:
            if (!(privateJwk.kty === 'RSA')) {
              _context2.next = 23;
              break;
            }

            if (typeof localOpt.name === 'undefined') localOpt.name = 'RSA-PSS';
            if (typeof localOpt.saltLength === 'undefined') localOpt.saltLength = _params.default.hashes[hash].hashSize;
            _context2.next = 20;
            return _jsCryptoRsa.default.sign(msg, privateJwk, hash, localOpt);

          case 20:
            signature = _context2.sent;
            _context2.next = 24;
            break;

          case 23:
            throw new Error('UnsupportedKeyType');

          case 24:
            return _context2.abrupt("return", signature);

          case 25:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function sign(_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Verify message with given public key
 * @param {Uint8Array} msg - A plaintext message to be verified.
 * @param {Uint8Array} sig - Signature byte array.
 * @param {Key} publicKey - Public key object for verification.
 * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.
 * @param {RSASigningOption|ECSigningOption} [options={}] - Signing options.
 * @return {Promise<boolean>} - Result of verification.
 * @throws {Error} - Throws if NonKeyObject or UnsupportedKeyType.
 */


exports.sign = sign;

var verify =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(msg, sig, publicKey) {
    var hash,
        options,
        publicJwk,
        localOpt,
        valid,
        _args3 = arguments;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            hash = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 'SHA-256';
            options = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : {};

            if (publicKey instanceof _key.Key) {
              _context3.next = 4;
              break;
            }

            throw new Error('NonKeyObject');

          case 4:
            _context3.next = 6;
            return publicKey.export('jwk');

          case 6:
            publicJwk = _context3.sent;
            localOpt = (0, _lodash.default)(options);

            if (!(publicJwk.kty === 'EC')) {
              _context3.next = 15;
              break;
            }

            if (typeof localOpt.format === 'undefined') localOpt.format = 'raw';
            _context3.next = 12;
            return _jsCryptoEc.default.verify(msg, sig, publicJwk, hash, localOpt.format);

          case 12:
            valid = _context3.sent;
            _context3.next = 24;
            break;

          case 15:
            if (!(publicJwk.kty === 'RSA')) {
              _context3.next = 23;
              break;
            }

            if (typeof localOpt.name === 'undefined') localOpt.name = 'RSA-PSS';
            if (typeof localOpt.saltLength === 'undefined') localOpt.saltLength = _params.default.hashes[hash].hashSize;
            _context3.next = 20;
            return _jsCryptoRsa.default.verify(msg, sig, publicJwk, hash, localOpt);

          case 20:
            valid = _context3.sent;
            _context3.next = 24;
            break;

          case 23:
            throw new Error('UnsupportedKeyType');

          case 24:
            return _context3.abrupt("return", valid);

          case 25:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function verify(_x3, _x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Encryption with public key algorithm. in case of ECDH.
 * Session key is derived from HKDF and the data itself will be encrypted by symmetric cipher.
 * @param {Uint8Array} msg - Plaintext message to be encrypted.
 * @param {Key} publicKey - Public key object.
 * @param {RSAEncryptionOption|ECEncryptionOptions} [options={}] - Encryption options.
 * @return {Promise<PKCCiphertextObject>} - Encrypted message object.
 * @throws {Error} - Throws if NonKeyObject, MissingOrInvalidPrivateKeyForECDH, or UnsupportedKeyType.
 */


exports.verify = verify;

var encrypt =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee4(msg, publicKey) {
    var options,
        publicJwk,
        localOpt,
        ciphertext,
        _args4 = arguments;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};

            if (publicKey instanceof _key.Key) {
              _context4.next = 3;
              break;
            }

            throw new Error('NonKeyObject');

          case 3:
            _context4.next = 5;
            return publicKey.export('jwk');

          case 5:
            publicJwk = _context4.sent;
            localOpt = (0, _lodash.default)(options);
            ciphertext = {};

            if (!(publicJwk.kty === 'EC')) {
              _context4.next = 19;
              break;
            }

            if (!(!localOpt.privateKey || !(localOpt.privateKey instanceof _key.Key))) {
              _context4.next = 11;
              break;
            }

            throw new Error('MissingOrInvalidPrivateKeyForECDH');

          case 11:
            _context4.next = 13;
            return localOpt.privateKey.export('jwk');

          case 13:
            localOpt.privateKey = _context4.sent;
            _context4.next = 16;
            return pkcec.encrypt(msg, publicJwk, localOpt);

          case 16:
            ciphertext = _context4.sent;
            _context4.next = 28;
            break;

          case 19:
            if (!(publicJwk.kty === 'RSA')) {
              _context4.next = 27;
              break;
            }

            if (typeof localOpt.hash !== 'undefined') localOpt.hash = 'SHA-256';
            if (typeof localOpt.label !== 'undefined') localOpt.label = new Uint8Array([]);
            _context4.next = 24;
            return _jsCryptoRsa.default.encrypt(msg, publicJwk, localOpt.hash, localOpt.label);

          case 24:
            ciphertext.data = _context4.sent;
            _context4.next = 28;
            break;

          case 27:
            throw new Error('UnsupportedKeyType');

          case 28:
            return _context4.abrupt("return", ciphertext);

          case 29:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function encrypt(_x6, _x7) {
    return _ref4.apply(this, arguments);
  };
}();
/**
 * Decryption with public key algorithm. in case of ECDH
 * Session key is derived from HKDF and the data itself will be decrypted by symmetric cipher.
 * @param {Uint8Array} data - Encrypted message body, i.e., PKCCiphertextObject.data.
 * @param {Key} privateKey - Private key object
 * @param {RSAEncryptionOption|ECDecryptionOptions} [options={}] - Decryption Options.
 * @return {Promise<Uint8Array>} - Decrypted message byte array.
 * @throws {Error} - Throws if NonKeyObject, MissingPublicKeyForECDH, or UnsupportedKeyType.
 */


exports.encrypt = encrypt;

var decrypt =
/*#__PURE__*/
function () {
  var _ref5 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee5(data, privateKey) {
    var options,
        privateJwk,
        localOpt,
        msg,
        _args5 = arguments;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};

            if (privateKey instanceof _key.Key) {
              _context5.next = 3;
              break;
            }

            throw new Error('NonKeyObject');

          case 3:
            _context5.next = 5;
            return privateKey.export('jwk');

          case 5:
            privateJwk = _context5.sent;
            localOpt = (0, _lodash.default)(options);

            if (!(privateJwk.kty === 'EC')) {
              _context5.next = 18;
              break;
            }

            if (localOpt.publicKey) {
              _context5.next = 10;
              break;
            }

            throw new Error('MissingPublicKeyForECDH');

          case 10:
            _context5.next = 12;
            return localOpt.publicKey.export('jwk');

          case 12:
            localOpt.publicKey = _context5.sent;
            _context5.next = 15;
            return pkcec.decrypt(data, privateJwk, localOpt);

          case 15:
            msg = _context5.sent;
            _context5.next = 27;
            break;

          case 18:
            if (!(privateJwk.kty === 'RSA')) {
              _context5.next = 26;
              break;
            }

            if (typeof localOpt.hash !== 'undefined') localOpt.hash = 'SHA-256';
            if (typeof localOpt.label !== 'undefined') localOpt.label = new Uint8Array([]);
            _context5.next = 23;
            return _jsCryptoRsa.default.decrypt(data, privateJwk, localOpt.hash, localOpt.label);

          case 23:
            msg = _context5.sent;
            _context5.next = 27;
            break;

          case 26:
            throw new Error('UnsupportedKeyType');

          case 27:
            return _context5.abrupt("return", msg);

          case 28:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function decrypt(_x8, _x9) {
    return _ref5.apply(this, arguments);
  };
}();

exports.decrypt = decrypt;