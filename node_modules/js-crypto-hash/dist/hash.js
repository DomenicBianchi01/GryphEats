"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compute = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var util = _interopRequireWildcard(require("js-crypto-env"));

var _params = _interopRequireDefault(require("./params.js"));

var _md = _interopRequireDefault(require("md5"));

var _sha = require("sha3");

var _hash = _interopRequireDefault(require("hash.js"));

/**
 * hash.js
 */

/**
 * Compute Hash value.
 * @param {Uint8Array} msg - Byte array of message to be hashed.
 * @param {String} [hash = 'SHA-256'] - Name of hash algorithm like 'SHA-256'.
 * @return {Promise<Uint8Array>} - Hash value
 * @throws {Error} - Throws if UnsupportedHashAlgorithm, UnsupportedMessageType,
 *  or UnsupportedEnvironment, i.e., a case where even pure js implementation won't work.
 */
var compute =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(msg) {
    var hash,
        webCrypto,
        nodeCrypto,
        msCrypto,
        msgHash,
        errMsg,
        native,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            hash = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'SHA-256';

            if (!(Object.keys(_params.default.hashes).indexOf(hash) < 0)) {
              _context.next = 3;
              break;
            }

            throw new Error('UnsupportedHashAlgorithm');

          case 3:
            if (msg instanceof Uint8Array) {
              _context.next = 5;
              break;
            }

            throw new Error('UnsupportedMessageType');

          case 5:
            webCrypto = util.getWebCrypto();
            nodeCrypto = util.getNodeCrypto();
            msCrypto = util.getMsCrypto();
            native = true;

            if (!(typeof webCrypto !== 'undefined' && typeof webCrypto.digest === 'function' && typeof msCrypto === 'undefined')) {
              _context.next = 15;
              break;
            }

            _context.next = 12;
            return webCrypto.digest(hash, msg).catch(function (e) {
              errMsg = e.message;
              native = false;
            });

          case 12:
            msgHash = _context.sent;
            _context.next = 26;
            break;

          case 15:
            if (!(typeof nodeCrypto !== 'undefined')) {
              _context.next = 19;
              break;
            }

            // for node
            try {
              msgHash = nodedigest(hash, msg, nodeCrypto);
            } catch (e) {
              errMsg = e.message;
              native = false;
            }

            _context.next = 26;
            break;

          case 19:
            if (!(typeof msCrypto !== 'undefined' && typeof msCrypto.digest === 'function')) {
              _context.next = 25;
              break;
            }

            _context.next = 22;
            return msdigest(hash, msg, msCrypto).catch(function (e) {
              errMsg = e.message;
              native = false;
            });

          case 22:
            msgHash = _context.sent;
            _context.next = 26;
            break;

          case 25:
            native = false;

          case 26:
            if (native) {
              _context.next = 35;
              break;
            }

            _context.prev = 27;
            msgHash = purejs(hash, msg);
            _context.next = 35;
            break;

          case 31:
            _context.prev = 31;
            _context.t0 = _context["catch"](27);
            errMsg = "".concat(errMsg, " => ").concat(_context.t0.message);
            throw new Error("UnsupportedEnvironment: ".concat(errMsg));

          case 35:
            return _context.abrupt("return", new Uint8Array(msgHash));

          case 36:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[27, 31]]);
  }));

  return function compute(_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Compute hash using MsCrypto implementation
 * @param {String} hash - Name of hash algorithm like SHA-256
 * @param {Uint8Array} msg - Byte array of message to be hashed.
 * @param {Object} msCrypto - msCrypto object.
 * @return {Promise<Uint8Array>} - Hash value.
 * @throws {Error} - Throws if hashing failed.
 */


exports.compute = compute;

var msdigest = function msdigest(hash, msg, msCrypto) {
  return new Promise(function (resolve, reject) {
    var op = msCrypto.digest(hash, msg);

    op.oncomplete = function (evt) {
      resolve(evt.target.result);
    };

    op.onerror = function (e) {
      reject(e);
    };
  });
};
/**
 * Compute hash using Node.js implementation
 * @param {String} hash - Name of hash algorithm like SHA-256
 * @param {Uint8Array} msg - Byte array of message to be hashed.
 * @param {Object} nodeCrypto - Node.js crypto object.
 * @return {Uint8Array} - Hash value.
 */


var nodedigest = function nodedigest(hash, msg, nodeCrypto) {
  var alg = _params.default.hashes[hash].nodeName;
  var hashFunc = nodeCrypto.createHash(alg);
  hashFunc.update(msg);
  return hashFunc.digest();
};
/**
 * Compute hash using pure js implementations
 * @param {String} hash - Name of hash algorithm like SHA-256
 * @param {Uint8Array} msg - Byte array of message to be hashed.
 * @return {Uint8Array} - Hash value.
 */


var purejs = function purejs(hash, msg) {
  var h;

  if (hash === 'MD5') {
    h = (0, _md.default)(Array.from(msg), {
      asBytes: true
    });
  } else if (['SHA3-512', 'SHA3-384', 'SHA3-256', 'SHA3-224'].indexOf(hash) >= 0) {
    // sha3
    var sha3obj = new _sha.SHA3(_params.default.hashes[hash].hashSize * 8);

    var Buffer = require('buffer/').Buffer;

    sha3obj.update(Buffer.from(msg));
    h = sha3obj.digest('binary');
  } else {
    h = _hash.default[_params.default.hashes[hash].nodeName]().update(msg).digest();
  }

  return new Uint8Array(h);
};