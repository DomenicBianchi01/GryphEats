"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decrypt = exports.encrypt = exports.verify = exports.sign = exports.generateKey = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _params = _interopRequireDefault(require("./params.js"));

var _jsCryptoKeyUtils = require("js-crypto-key-utils");

var _jsEncodingUtils = _interopRequireDefault(require("js-encoding-utils"));

var oaep = _interopRequireWildcard(require("./oaep.js"));

var _bn = _interopRequireDefault(require("bn.js"));

/**
 * nodeapi.js
 */

/**
 * Generate RSA public/private key pair.
 * @param {Number} modulusLength - Modulus length in bits, i.e., n.
 * @param {Uint8Array} publicExponent - Public exponent, i.e, e.
 * @param {Object} nodeCrypto - NodeCrypto object.
 * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>}
 * @throws {Error} - Throws if KeyGenerationFailedNode.
 */
var generateKey =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(modulusLength, publicExponent, nodeCrypto) {
    var pe, options, nodeKeyGen, keyPairDer, publicObj, privateObj;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            pe = new _bn.default(publicExponent);
            options = {
              modulusLength: typeof modulusLength !== 'number' ? parseInt(modulusLength, 10) : modulusLength,
              publicExponent: pe.toNumber(),
              publicKeyEncoding: {
                type: 'spki',
                format: 'der'
              },
              privateKeyEncoding: {
                type: 'pkcs8',
                format: 'der'
              }
            };

            nodeKeyGen = function nodeKeyGen() {
              return new Promise(function (resolve, reject) {
                nodeCrypto.generateKeyPair('rsa', options, function (err, publicKey, privateKey) {
                  if (err) reject('KeyGenerationFailedNode');else resolve({
                    publicKey: publicKey,
                    privateKey: privateKey
                  });
                });
              });
            };

            _context.next = 5;
            return nodeKeyGen().catch(function () {
              throw new Error('KeyGenerationFailedNode');
            });

          case 5:
            keyPairDer = _context.sent;
            publicObj = new _jsCryptoKeyUtils.Key('der', new Uint8Array(keyPairDer.publicKey));
            privateObj = new _jsCryptoKeyUtils.Key('der', new Uint8Array(keyPairDer.privateKey));
            _context.next = 10;
            return publicObj.export('jwk');

          case 10:
            _context.t0 = _context.sent;
            _context.next = 13;
            return privateObj.export('jwk');

          case 13:
            _context.t1 = _context.sent;
            return _context.abrupt("return", {
              publicKey: _context.t0,
              privateKey: _context.t1
            });

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function generateKey(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * RSA signing via RSA-PSS or RSASSA-PKCS1-v1_5 in Node.js.
 * @param {Uint8Array} msg - Byte array of message to be signed.
 * @param {JsonWebKey} privateJwk - Private key for signing in JWK format.
 * @param {String} hash - Name of hash algorithm like 'SHA-256'.
 * @param {Object} algorithm - Object to specify algorithm parameters.
 * @param {Object} nodeCrypto - NodeCrypto object
 * @return {Promise<Uint8Array>} - Byte array of raw signature.
 * @throws {Error} - Throws if NotPublicKeyForRSASign.
 */


exports.generateKey = generateKey;

var sign =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(msg, privateJwk, hash, algorithm, nodeCrypto) {
    var keyObj, privatePem, sign, opt;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            keyObj = new _jsCryptoKeyUtils.Key('jwk', privateJwk);

            if (keyObj.isPrivate) {
              _context2.next = 3;
              break;
            }

            throw new Error('NotPrivateKeyForRSASign');

          case 3:
            _context2.next = 5;
            return keyObj.export('pem');

          case 5:
            privatePem = _context2.sent;
            sign = nodeCrypto.createSign(_params.default.hashes[hash].nodeName);
            sign.update(msg);
            opt = algorithm.name === 'RSA-PSS' ? {
              saltLength: algorithm.saltLength,
              padding: nodeCrypto.constants.RSA_PKCS1_PSS_PADDING
            } : {};
            return _context2.abrupt("return", new Uint8Array(sign.sign(Object.assign({
              key: privatePem
            }, opt))));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function sign(_x4, _x5, _x6, _x7, _x8) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 /**
 * Verification of RSA signature via RSA-PSS or RSASSA-PKCS1-v1_5 in Node.js.
 * @param {Uint8Array} msg - Byte array of message signed.
 * @param {Uint8Array} signature - Byte array of raw signature.
 * @param {JsonWebKey} publicJwk - public key for signing in JWK format.
 * @param {String} hash - Name of hash algorithm like 'SHA-256'.
 * @param {Object} algorithm - Object to specify algorithm parameters.
 * @param {Object} nodeCrypto - NodeCrypto object
 * @return {Promise<boolean>} - Result of verification.
 * @throws {Error} - Throws if NotPublicKeyForRSAVerify.
 */


exports.sign = sign;

var verify =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(msg, signature, publicJwk, hash, algorithm, nodeCrypto) {
    var keyObj, publicPem, verify, opt;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            keyObj = new _jsCryptoKeyUtils.Key('jwk', publicJwk);

            if (!keyObj.isPrivate) {
              _context3.next = 3;
              break;
            }

            throw new Error('NotPublicKeyForRSAVerify');

          case 3:
            _context3.next = 5;
            return keyObj.export('pem', {
              outputPublic: true
            });

          case 5:
            publicPem = _context3.sent;
            verify = nodeCrypto.createVerify(_params.default.hashes[hash].nodeName);
            verify.update(msg);
            opt = algorithm.name === 'RSA-PSS' ? {
              saltLength: algorithm.saltLength,
              padding: nodeCrypto.constants.RSA_PKCS1_PSS_PADDING
            } : {};
            return _context3.abrupt("return", verify.verify(Object.assign({
              key: publicPem
            }, opt), signature));

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function verify(_x9, _x10, _x11, _x12, _x13, _x14) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * RSA Encryption via NodeCrypto.
 * @param {Uint8Array} msg - Byte array of message to be encrypted
 * @param {JsonWebKey} publicJwk - Public key in JWK format.
 * @param {String} hash - Name of hash algorithm like 'SHA-256'
 * @param {Uint8Array} label - RSA-OAEP label.
 * @param {Object} nodeCrypto - NodeCrypto object.
 * @return {Promise<Uint8Array>} - Encrypted message.
 * @throws {Error} - Throws if NotPublicKeyForRSAEncrypt.
 */


exports.verify = verify;

var encrypt =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee4(msg, publicJwk) {
    var hash,
        label,
        nodeCrypto,
        keyObj,
        publicPem,
        encrypted,
        em,
        _args4 = arguments;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            hash = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : 'SHA-256';
            label = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : new Uint8Array([]);
            nodeCrypto = _args4.length > 4 ? _args4[4] : undefined;
            keyObj = new _jsCryptoKeyUtils.Key('jwk', publicJwk);

            if (!keyObj.isPrivate) {
              _context4.next = 6;
              break;
            }

            throw new Error('NotPublicKeyForRSAEncrypt');

          case 6:
            _context4.next = 8;
            return keyObj.export('pem', {
              outputPublic: true
            });

          case 8:
            publicPem = _context4.sent;

            if (!(hash === 'SHA-1')) {
              _context4.next = 13;
              break;
            }

            encrypted = nodeCrypto.publicEncrypt({
              key: publicPem,
              padding: nodeCrypto.constants.RSA_PKCS1_OAEP_PADDING
            }, msg);
            _context4.next = 17;
            break;

          case 13:
            _context4.next = 15;
            return oaep.emeOaepEncode(msg, label, _jsEncodingUtils.default.encoder.decodeBase64Url(publicJwk.n).length, hash);

          case 15:
            em = _context4.sent;
            encrypted = nodeCrypto.publicEncrypt({
              key: publicPem,
              padding: nodeCrypto.constants.RSA_NO_PADDING
            }, em);

          case 17:
            return _context4.abrupt("return", new Uint8Array(encrypted));

          case 18:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function encrypt(_x15, _x16) {
    return _ref4.apply(this, arguments);
  };
}();
/**
 * RSA Decryption via NodeCrypto.
 * @param {Uint8Array} data - encrypted message byte array.
 * @param {JsonWebKey} privateJwk - Private key in JWK format.
 * @param {String} hash - Name of hash algorithm like 'SHA-256'
 * @param {Uint8Array} label - RSA-OAEP label.
 * @param {Object} nodeCrypto - NodeCrypto object.
 * @return {Promise<Uint8Array>} - Decrypted message.
 * @throws {Error} - Throws if NotPrivateKeyForRSADecrypt.
 */


exports.encrypt = encrypt;

var decrypt =
/*#__PURE__*/
function () {
  var _ref5 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee5(data, privateJwk) {
    var hash,
        label,
        nodeCrypto,
        keyObj,
        privatePem,
        decrypted,
        em,
        _args5 = arguments;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            hash = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : 'SHA-256';
            label = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : new Uint8Array([]);
            nodeCrypto = _args5.length > 4 ? _args5[4] : undefined;
            keyObj = new _jsCryptoKeyUtils.Key('jwk', privateJwk);

            if (keyObj.isPrivate) {
              _context5.next = 6;
              break;
            }

            throw new Error('NotPrivateKeyForRSADecrypt');

          case 6:
            _context5.next = 8;
            return keyObj.export('pem');

          case 8:
            privatePem = _context5.sent;

            if (!(hash === 'SHA-1')) {
              _context5.next = 13;
              break;
            }

            decrypted = nodeCrypto.privateDecrypt({
              key: privatePem,
              padding: nodeCrypto.constants.RSA_PKCS1_OAEP_PADDING
            }, data);
            _context5.next = 17;
            break;

          case 13:
            // https://tools.ietf.org/html/rfc3447
            em = nodeCrypto.privateDecrypt({
              key: privatePem,
              padding: nodeCrypto.constants.RSA_NO_PADDING
            }, data);
            _context5.next = 16;
            return oaep.emeOaepDecode(new Uint8Array(em), label, _jsEncodingUtils.default.encoder.decodeBase64Url(privateJwk.n).length, hash);

          case 16:
            decrypted = _context5.sent;

          case 17:
            return _context5.abrupt("return", new Uint8Array(decrypted));

          case 18:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function decrypt(_x17, _x18) {
    return _ref5.apply(this, arguments);
  };
}();

exports.decrypt = decrypt;