"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encrypt = encrypt;
exports.decrypt = exports.verify = exports.sign = exports.generateKey = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var util = _interopRequireWildcard(require("js-crypto-env"));

var webapi = _interopRequireWildcard(require("./webapi.js"));

var nodeapi = _interopRequireWildcard(require("./nodeapi.js"));

var _params = _interopRequireDefault(require("./params.js"));

var _oaep = require("./oaep.js");

var _pss = require("./pss.js");

var _jsEncodingUtils = _interopRequireDefault(require("js-encoding-utils"));

/**
 * rsa.js
 */

/**
 * Generate RSA public/private key pair.
 * @param {Number} [modulusLength=2048] - Modulus length in bits, i.e., n.
 * @param {Uint8Array} [publicExponent=new Uint8Array([0x01, 0x00, 0x01])] - Public exponent, i.e, e.
 * @return {Promise<{publicKey: JsonWebKey, privateKey: JsonWebKey}>}
 * @throws {Error} - Throws if UnsupportedEnvironment.
 */
var generateKey =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee() {
    var modulusLength,
        publicExponent,
        webCrypto,
        nodeCrypto,
        errMsg,
        keyPair,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            modulusLength = _args.length > 0 && _args[0] !== undefined ? _args[0] : 2048;
            publicExponent = _args.length > 1 && _args[1] !== undefined ? _args[1] : new Uint8Array([0x01, 0x00, 0x01]);
            webCrypto = util.getWebCryptoAll(); // web crypto api

            nodeCrypto = util.getNodeCrypto(); // implementation on node.js

            keyPair = {};

            if (!(typeof webCrypto !== 'undefined' && typeof webCrypto.generateKey === 'function' && typeof webCrypto.exportKey === 'function')) {
              _context.next = 11;
              break;
            }

            _context.next = 8;
            return webapi.generateKey(modulusLength, publicExponent, webCrypto).catch(function (e) {
              errMsg = e.message;
            });

          case 8:
            keyPair = _context.sent;
            _context.next = 18;
            break;

          case 11:
            if (!(typeof nodeCrypto !== 'undefined')) {
              _context.next = 17;
              break;
            }

            _context.next = 14;
            return nodeapi.generateKey(modulusLength, publicExponent, nodeCrypto).catch(function (e) {
              errMsg = e.message;
            });

          case 14:
            keyPair = _context.sent;
            _context.next = 18;
            break;

          case 17:
            throw new Error('UnsupportedEnvironment');

          case 18:
            if (!errMsg) {
              _context.next = 20;
              break;
            }

            throw new Error("UnsupportedEnvironment: ".concat(errMsg));

          case 20:
            return _context.abrupt("return", keyPair);

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function generateKey() {
    return _ref.apply(this, arguments);
  };
}();
/**
 * RSA Signing parameter check.
 * @param {Uint8Array} msg - Byte array of message to be signed.
 * @param {JsonWebKey} jwkey - Private/Public key for signing/verifying in JWK format.
 * @param {String} hash - Name of hash algorithm like 'SHA-256'.
 * @param {RSASignAlgorithm} algorithm - Object to specify algorithm parameters.
 * @param {String} mode - 'sign' or 'verify' for PSS parameter check.
 * @return {boolean} - Always true unless thrown.
 * @throws {Error} - Throws if InvalidAlgorithm, UnsupportedHash, InvalidMessageFormat or InvalidJwkRsaKey
 */


exports.generateKey = generateKey;

var assertSignVerify = function assertSignVerify(msg, jwkey, hash, algorithm, mode) {
  if (algorithm.name !== 'RSA-PSS' && algorithm.name !== 'RSASSA-PKCS1-v1_5') throw new Error('InvalidAlgorithm');
  if (Object.keys(_params.default.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHash');
  if (!(msg instanceof Uint8Array)) throw new Error('InvalidMessageFormat');
  if (jwkey.kty !== 'RSA') throw new Error('InvalidJwkRsaKey');

  if (algorithm.name === 'RSA-PSS') {
    (0, _pss.checkLength)(mode, {
      k: _jsEncodingUtils.default.encoder.decodeBase64Url(jwkey.n).length,
      hash: hash,
      saltLength: algorithm.saltLength
    });
  }

  return true;
};
/**
 * RSA signing via RSA-PSS or RSASSA-PKCS1-v1_5.
 * @param {Uint8Array} msg - Byte array of message to be signed.
 * @param {JsonWebKey} privateJwk - Private key for signing in JWK format.
 * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.
 * @param {RSASignAlgorithm} [algorithm={name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}] - Object to specify algorithm parameters.
 * @return {Promise<Uint8Array>} - Byte array of raw signature.
 * @throws {Error} - Throws if UnsupportedEnvironment.
 */


var sign =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(msg, privateJwk) {
    var hash,
        algorithm,
        webCrypto,
        nodeCrypto,
        errMsg,
        signature,
        _args2 = arguments;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            hash = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 'SHA-256';
            algorithm = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {
              name: 'RSA-PSS',
              saltLength: _params.default.hashes[hash].hashSize
            };
            // assertion
            assertSignVerify(msg, privateJwk, hash, algorithm, 'sign');
            webCrypto = util.getWebCryptoAll(); // web crypto api

            nodeCrypto = util.getNodeCrypto(); // implementation on node.js

            if (!(typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.sign === 'function')) {
              _context2.next = 11;
              break;
            }

            _context2.next = 8;
            return webapi.sign(msg, privateJwk, hash, algorithm, webCrypto).catch(function (e) {
              errMsg = e.message;
            });

          case 8:
            signature = _context2.sent;
            _context2.next = 18;
            break;

          case 11:
            if (!(typeof nodeCrypto !== 'undefined')) {
              _context2.next = 17;
              break;
            }

            _context2.next = 14;
            return nodeapi.sign(msg, privateJwk, hash, algorithm, nodeCrypto).catch(function (e) {
              errMsg = e.message;
            });

          case 14:
            signature = _context2.sent;
            _context2.next = 18;
            break;

          case 17:
            throw new Error('UnsupportedEnvironment');

          case 18:
            if (!errMsg) {
              _context2.next = 20;
              break;
            }

            throw new Error("UnsupportedEnvironment: ".concat(errMsg));

          case 20:
            return _context2.abrupt("return", signature);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function sign(_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Verification of RSA signature via RSA-PSS or RSASSA-PKCS1-v1_5.
 * @param {Uint8Array} msg - Byte array of message signed.
 * @param {Uint8Array} signature - Byte array of raw signature.
 * @param {JsonWebKey} publicJwk - public key for signing in JWK format.
 * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'.
 * @param {RSASignAlgorithm} [algorithm={name: 'RSA-PSS', saltLength: params.hashes[hash].hashSize}] - Object to specify algorithm parameters.
 * @return {Promise<boolean>} - Result of verification.
 * @throws {Error} - Throws if InvalidSignatureFormat, or UnsupportedEnvironment.
 */


exports.sign = sign;

var verify =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(msg, signature, publicJwk) {
    var hash,
        algorithm,
        webCrypto,
        nodeCrypto,
        errMsg,
        valid,
        _args3 = arguments;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            hash = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 'SHA-256';
            algorithm = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : {
              name: 'RSA-PSS',
              saltLength: _params.default.hashes[hash].hashSize
            };
            // assertion
            assertSignVerify(msg, publicJwk, hash, algorithm, 'verify');

            if (signature instanceof Uint8Array) {
              _context3.next = 5;
              break;
            }

            throw new Error('InvalidSignatureFormat');

          case 5:
            webCrypto = util.getWebCryptoAll(); // web crypto api

            nodeCrypto = util.getNodeCrypto(); // implementation on node.js

            if (!(typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.verify === 'function')) {
              _context3.next = 13;
              break;
            }

            _context3.next = 10;
            return webapi.verify(msg, signature, publicJwk, hash, algorithm, webCrypto).catch(function (e) {
              errMsg = e.message;
            });

          case 10:
            valid = _context3.sent;
            _context3.next = 20;
            break;

          case 13:
            if (!(typeof nodeCrypto !== 'undefined')) {
              _context3.next = 19;
              break;
            }

            _context3.next = 16;
            return nodeapi.verify(msg, signature, publicJwk, hash, algorithm, nodeCrypto).catch(function (e) {
              errMsg = e.message;
            });

          case 16:
            valid = _context3.sent;
            _context3.next = 20;
            break;

          case 19:
            throw new Error('UnsupportedEnvironment');

          case 20:
            if (!errMsg) {
              _context3.next = 22;
              break;
            }

            throw new Error("UnsupportedEnvironment: ".concat(errMsg));

          case 22:
            return _context3.abrupt("return", valid);

          case 23:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function verify(_x3, _x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * RSA Encryption/Decryption Parameter Check.
 * @param {Uint8Array} data - message or encrypted message byte array.
 * @param {JsonWebKey} jwkey - Public/Private key in JWK format.
 * @param {String} hash - Name of hash algorithm like 'SHA-256'
 * @param {Uint8Array} label - RSA-OAEP label.
 * @param {String} mode - 'encrypt' or 'decrypt'
 * @return {boolean} - Always true, otherwise thrown.
 * @throws {Error} - Throws if UnsuppotedHash, InvalidMessageFormat, InvalidLabelFormat or InvalidJwkRsaKey.
 */


exports.verify = verify;

var assertEncryptDecrypt = function assertEncryptDecrypt(data, jwkey, hash, label, mode) {
  if (Object.keys(_params.default.hashes).indexOf(hash) < 0) throw new Error('UnsupportedHash');
  if (!(data instanceof Uint8Array)) throw new Error('InvalidMessageFormat');
  if (!(label instanceof Uint8Array)) throw new Error('InvalidLabelFormat');
  if (jwkey.kty !== 'RSA') throw new Error('InvalidJwkRsaKey');
  (0, _oaep.checkLength)(mode, Object.assign({
    k: _jsEncodingUtils.default.encoder.decodeBase64Url(jwkey.n).length,
    label: label,
    hash: hash
  }, mode === 'encrypt' ? {
    mLen: data.length,
    cLen: 0
  } : {
    mLen: 0,
    cLen: data.length
  }));
  return true;
};
/**
 * RSA-OAEP Encryption
 * @param {Uint8Array} msg - Byte array of message to be encrypted.
 * @param {JsonWebKey} publicJwk - Public/Private key in JWK format.
 * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'
 * @param {Uint8Array} [label=new Uint8Array([])] - RSA-OAEP label.
 * @return {Promise<Uint8Array>} - Encrypted message.
 * @throws {Error} - Throws if UnsupportedEnvironment.
 */


function encrypt(_x6, _x7) {
  return _encrypt.apply(this, arguments);
}
/**
 * RSA-OAEP Decryption.
 * @param {Uint8Array} data - Byte array of encrypted message to be decrypted.
 * @param {JsonWebKey} privateJwk - Private key in JWK format.
 * @param {String} [hash='SHA-256'] - Name of hash algorithm like 'SHA-256'
 * @param {Uint8Array} [label=new Uint8Array([])] - RSA-OAEP label.
 * @return {Promise<Uint8Array>} - Decrypted message.
 * @throws {Error} - Throws if UnsupportedEnvironment.
 */


function _encrypt() {
  _encrypt = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee5(msg, publicJwk) {
    var hash,
        label,
        webCrypto,
        nodeCrypto,
        errMsg,
        encrypted,
        _args5 = arguments;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            hash = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : 'SHA-256';
            label = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : new Uint8Array([]);
            // assertion
            assertEncryptDecrypt(msg, publicJwk, hash, label, 'encrypt');
            webCrypto = util.getWebCryptoAll(); // web crypto api

            nodeCrypto = util.getNodeCrypto(); // implementation on node.js

            if (!(typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.encrypt === 'function')) {
              _context5.next = 11;
              break;
            }

            _context5.next = 8;
            return webapi.encrypt(msg, publicJwk, hash, label, webCrypto).catch(function (e) {
              errMsg = e.message;
            });

          case 8:
            encrypted = _context5.sent;
            _context5.next = 16;
            break;

          case 11:
            if (!(typeof nodeCrypto !== 'undefined')) {
              _context5.next = 15;
              break;
            }

            // for node
            try {
              encrypted = nodeapi.encrypt(msg, publicJwk, hash, label, nodeCrypto);
            } catch (e) {
              errMsg = e.message;
            }

            _context5.next = 16;
            break;

          case 15:
            throw new Error('UnsupportedEnvironment');

          case 16:
            if (!errMsg) {
              _context5.next = 18;
              break;
            }

            throw new Error("UnsupportedEnvironment: ".concat(errMsg));

          case 18:
            return _context5.abrupt("return", encrypted);

          case 19:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _encrypt.apply(this, arguments);
}

var decrypt =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee4(data, privateJwk) {
    var hash,
        label,
        webCrypto,
        nodeCrypto,
        errMsg,
        decrypted,
        _args4 = arguments;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            hash = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : 'SHA-256';
            label = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : new Uint8Array([]);
            // assertion
            assertEncryptDecrypt(data, privateJwk, hash, label, 'decrypt');
            webCrypto = util.getWebCryptoAll(); // web crypto api

            nodeCrypto = util.getNodeCrypto(); // implementation on node.js

            if (!(typeof webCrypto !== 'undefined' && typeof webCrypto.importKey === 'function' && typeof webCrypto.decrypt === 'function')) {
              _context4.next = 11;
              break;
            }

            _context4.next = 8;
            return webapi.decrypt(data, privateJwk, hash, label, webCrypto).catch(function (e) {
              errMsg = e.message;
            });

          case 8:
            decrypted = _context4.sent;
            _context4.next = 16;
            break;

          case 11:
            if (!(typeof nodeCrypto !== 'undefined')) {
              _context4.next = 15;
              break;
            }

            // for node
            try {
              decrypted = nodeapi.decrypt(data, privateJwk, hash, label, nodeCrypto);
            } catch (e) {
              errMsg = e.message;
            }

            _context4.next = 16;
            break;

          case 15:
            throw new Error('UnsupportedEnvironment');

          case 16:
            if (!errMsg) {
              _context4.next = 18;
              break;
            }

            throw new Error("UnsupportedEnvironment: ".concat(errMsg));

          case 18:
            return _context4.abrupt("return", decrypted);

          case 19:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function decrypt(_x8, _x9) {
    return _ref4.apply(this, arguments);
  };
}();

exports.decrypt = decrypt;